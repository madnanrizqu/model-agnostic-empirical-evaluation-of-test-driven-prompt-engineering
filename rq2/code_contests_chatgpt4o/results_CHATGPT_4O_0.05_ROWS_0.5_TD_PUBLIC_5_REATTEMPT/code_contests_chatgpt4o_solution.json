[
    {
        "dataset_name": "code_contests_chatgpt4o",
        "dataset_row_id": 0.0,
        "solution": "```python\n===START===\nimport math\n\ndef solve_problem(input_str: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n    \n    lines = input_str.strip().split(\"\\n\")\n    T = int(lines[0])\n    results = []\n    index = 1\n    \n    for _ in range(T):\n        R = int(lines[index])\n        index += 1\n        chef_x, chef_y = map(int, lines[index].split())\n        index += 1\n        head_x, head_y = map(int, lines[index].split())\n        index += 1\n        sous_x, sous_y = map(int, lines[index].split())\n        index += 1\n        \n        # Calculate distances\n        d1 = distance(chef_x, chef_y, head_x, head_y)\n        d2 = distance(chef_x, chef_y, sous_x, sous_y)\n        d3 = distance(head_x, head_y, sous_x, sous_y)\n        \n        # Check communication possibilities\n        if (d1 <= R and d2 <= R) or (d1 <= R and d3 <= R) or (d2 <= R and d3 <= R):\n            results.append(\"yes\")\n        else:\n            results.append(\"no\")\n    \n    return \"\\n\".join(results)\n===END===\n```",
        "llm_name": "openai/gpt-4o-2024-11-20",
        "prompt": "### Prompt\nThe Chef likes to stay in touch with his staff. So, the Chef, the head server, and the sous-chef all carry two-way transceivers so they can stay in constant contact. Of course, these transceivers have a limited range so if two are too far apart, they cannot communicate directly.\n\n\nThe Chef invested in top-of-the-line transceivers which have a few advanced features. One is that even if two people cannot talk directly because they are out of range, if there is another transceiver that is close enough to both, then the two transceivers can still communicate with each other using the third transceiver as an intermediate device.\n\n\nThere has been a minor emergency in the Chef's restaurant\nand he needs to communicate with both the head server and the sous-chef right away. Help the Chef determine if it is possible for all three people to communicate with each other, even if two must communicate through the third because they are too far apart.\n\n\nInput\n\nThe first line contains a single positive integer T \u2264 100 indicating the number of test cases to follow. The first line of each test case contains a positive integer R \u2264 1,000 indicating that two transceivers can communicate directly without an intermediate transceiver if they are at most R meters away from each other. The remaining three lines of the test case describe the current locations of the Chef, the head server, and the sous-chef, respectively. Each such line contains two integers X,Y (at most 10,000 in absolute value) indicating that the respective person is located at position X,Y.\n\n\nOutput\n\nFor each test case you are to output a single line containing a single string. If it is possible for all three to communicate then you should output \"yes\". Otherwise, you should output \"no\".\n\n\nTo be clear, we say that two transceivers are close enough to communicate directly if the length of the straight line connecting their X,Y coordinates is at most R.\n\n\nExample\n\nInput:\n3\n1\n0 1\n0 0\n1 0\n2\n0 1\n0 0\n1 0\n2\n0 0\n0 2\n2 1\n\n\nOutput:\nyes\nyes\nno\n\n### Signature\ndef solve_problem(input_str: str) -> str:",
        "timestamp": "2025-10-16T20:59:02.550463",
        "response_time": "4.94",
        "context": "{\"function_name\": \"solve_problem\", \"difficulty\": 1, \"difficulty_label\": \"EASY\"}"
    },
    {
        "dataset_name": "code_contests_chatgpt4o",
        "dataset_row_id": 1.0,
        "solution": "```python\n===START===\ndef gcd(a: int, b: int) -> int:\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef solve_problem(input_str: str) -> str:\n    input_lines = input_str.strip().split(\"\\n\")\n    num_cases = int(input_lines[0])\n    results = []\n    \n    for i in range(1, num_cases + 1):\n        a, b = input_lines[i].split()\n        a = int(a)\n        b_mod_a = 0\n        \n        # Calculate b % a efficiently for very large b\n        for digit in b:\n            b_mod_a = (b_mod_a * 10 + int(digit)) % a\n        \n        # Compute GCD of a and b % a\n        results.append(gcd(a, b_mod_a))\n    \n    return \"\\n\".join(map(str, results))\n===END===\n```",
        "llm_name": "openai/gpt-4o-2024-11-20",
        "prompt": "### Prompt\nFrank explained its friend Felman the algorithm of Euclides to calculate the GCD \nof two numbers. Then Felman implements it algorithm \n\n\nint gcd(int a, int b)\n{\n\tif (b==0)\n\t\treturn a;\n\telse\n\t\treturn gcd(b,a%b);\n}\n\nand it proposes to Frank that makes it \nbut with a little integer and another integer that has up to 250 digits. \nYour task is to help Frank programming an efficient code for the challenge of Felman.\n\n\n\nInput\nThe first line of the input file contains a number representing the number of lines to follow.\nEach line consists of two number A and B (0 \u2264 A \u2264 40000 and A \u2264 B < 10^250).\n\n\nOutput\nPrint for each pair (A,B) in the input one integer representing the GCD of A and B.\n\n\n\nExample\n\nInput:\n2\n2 6\n10 11\n\n\nOutput:\n2\n1\n\n### Signature\ndef solve_problem(input_str: str) -> str:",
        "timestamp": "2025-10-16T20:59:06.437288",
        "response_time": "3.89",
        "context": "{\"function_name\": \"solve_problem\", \"difficulty\": 2, \"difficulty_label\": \"MEDIUM\"}"
    },
    {
        "dataset_name": "code_contests_chatgpt4o",
        "dataset_row_id": 2.0,
        "solution": "```python\n===START===\ndef solve_problem(input_str: str) -> str:\n    input_lines = input_str.strip().split(\"\\n\")\n    T = int(input_lines[0])  # Number of test cases\n    results = []\n    \n    for t in range(T):\n        S = input_lines[t + 1]\n        n = len(S)\n        \n        # Prefix sums for counting 4s and 7s\n        prefix_4 = [0] * (n + 1)\n        prefix_7 = [0] * (n + 1)\n        \n        for i in range(1, n + 1):\n            prefix_4[i] = prefix_4[i - 1] + (1 if S[i - 1] == '4' else 0)\n            prefix_7[i] = prefix_7[i - 1] + (1 if S[i - 1] == '7' else 0)\n        \n        # Dictionary to store the difference between counts of 4s and 7s\n        diff_count = {}\n        diff_count[0] = 1  # Initial state where diff is 0\n        count_balanced = 0\n        \n        for i in range(1, n + 1):\n            diff = prefix_4[i] - prefix_7[i]\n            if diff in diff_count:\n                count_balanced += diff_count[diff]\n            diff_count[diff] = diff_count.get(diff, 0) + 1\n        \n        results.append(count_balanced)\n    \n    return \"\\n\".join(map(str, results))\n===END===\n```",
        "llm_name": "openai/gpt-4o-2024-11-20",
        "prompt": "### Prompt\nA Little Elephant from the Zoo of Lviv likes lucky strings, i.e., the strings that consist only of the lucky digits 4 and 7.\nThe Little Elephant calls some string T of the length M balanced if there exists at least one integer X (1 \u2264 X \u2264 M) such that the number of digits 4 in the substring T[1, X - 1] is equal to the number of digits 7 in the substring T[X, M]. For example, the string S = 7477447 is balanced since S[1, 4] = 7477 has 1 digit 4 and S[5, 7] = 447 has 1 digit 7. On the other hand, one can verify that the string S = 7 is not balanced.\n The Little Elephant has the string S of the length N. He wants to know the number of such pairs of integers (L; R) that 1 \u2264 L \u2264 R \u2264 N and the substring S[L, R]  is balanced. Help him to find this number.\nNotes.\n\nLet S be some lucky string. Then\n\n\n|S| denotes the length of the string S;\n\nS[i] (1 \u2264 i \u2264 |S|) denotes the i^th character of S (the numeration of characters starts from 1);\n\n S[L, R] (1 \u2264 L \u2264 R \u2264 |S|) denotes the string with the following sequence of characters: S[L], S[L + 1], ..., S[R], and is called a substring of S. For L > R we mean by S[L, R] an empty string.\n\n\n\nInput\nThe first line of the input file contains a single integer T, the number of test cases. Each of the following T lines contains one string, the string S for the corresponding test case. The input file does not contain any whitespaces.\n\nOutput\nFor each test case output a single line containing the answer for this test case.\n\n\nConstraints\n 1 \u2264 T \u2264 10\n 1 \u2264 |S| \u2264 100000\n S consists only of the lucky digits 4 and 7.\n\n\n\nExample\n\nInput:\n4\n47\n74\n477\n4747477\n\nOutput:\n2\n2\n3\n23\n\n\n\nExplanation\nIn the first test case balance substrings are S[1, 1] = 4 and S[1, 2] = 47.\nIn the second test case balance substrings are S[2, 2] = 4 and S[1, 2] = 74.\nUnfortunately, we can't provide you with the explanations of the third and the fourth test cases. You should figure it out by yourself. Please, don't ask about this in comments.\n\n### Signature\ndef solve_problem(input_str: str) -> str:",
        "timestamp": "2025-10-16T20:59:12.869408",
        "response_time": "6.43",
        "context": "{\"function_name\": \"solve_problem\", \"difficulty\": 2, \"difficulty_label\": \"MEDIUM\"}"
    },
    {
        "dataset_name": "code_contests_chatgpt4o",
        "dataset_row_id": 3.0,
        "solution": "```python\n===START===\ndef solve_problem(input_str: str) -> str:\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    lines = input_str.strip().split(\"\\n\")\n    T = int(lines[0])  # Number of test cases\n    results = []\n    \n    for i in range(1, T + 1):\n        s = lines[i]\n        n = len(s)\n        found = False\n        \n        for j in range(n):\n            # Remove the j-th character and check if the resulting string is a palindrome\n            if is_palindrome(s[:j] + s[j+1:]):\n                found = True\n                break\n        \n        if found:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return \"\\n\".join(results)\n===END===\n```",
        "llm_name": "openai/gpt-4o-2024-11-20",
        "prompt": "### Prompt\nGiven a string s. Can you make it a palindrome by deleting exactly one character? Note that size of the string after deletion would be one less than it was before. \n\nInput\nFirst line of the input contains a single integer T denoting number of test cases.\nFor each test case, you are given a single line containing string  s. \n\nOutput\nFor each test case, print YES or NO depending on the answer of the problem. \n\nConstraints\n\n Example\nInput:\n4\naaa\nabc\nabdbca\nabba\n\nOutput:\nYES\nNO\nYES\nYES\n\nExplanation\nExample case 1. Delete any one 'a', resulting string is \"aa\" which is a palindrome.\nExample case 2. It is not possible to delete exactly one character and having a palindrome.\nExample case 3. Delete 'c', resulting string is \"abdba\" which is a palindrome. \nExample case 4. Delete 'b', resulting string is \"aba\" which is a palindrome.\n\n### Signature\ndef solve_problem(input_str: str) -> str:",
        "timestamp": "2025-10-16T20:59:16.284211",
        "response_time": "3.41",
        "context": "{\"function_name\": \"solve_problem\", \"difficulty\": 2, \"difficulty_label\": \"MEDIUM\"}"
    },
    {
        "dataset_name": "code_contests_chatgpt4o",
        "dataset_row_id": 4.0,
        "solution": "```python\n===START===\ndef solve_problem(input_str: str) -> str:\n    # Parse the input\n    lines = input_str.strip().split(\"\\n\")\n    T = int(lines[0])  # Number of test cases\n    results = []\n    \n    for i in range(1, T + 1):\n        N = int(lines[i])\n        # The optimal package size A is (N // 2) + 1\n        # This ensures the maximum leftover cupcakes\n        results.append((N // 2) + 1)\n    \n    # Join the results into a single string separated by newlines\n    return \"\\n\".join(map(str, results))\n===END===\n```",
        "llm_name": "openai/gpt-4o-2024-11-20",
        "prompt": "### Prompt\nNow that Chef has finished baking and frosting his cupcakes, it's time to package them. Chef has N cupcakes, and needs to decide how many cupcakes to place in each package. Each package must contain the same number of cupcakes. Chef will choose an integer A between 1 and N, inclusive, and place exactly A cupcakes into each package.  Chef makes as many packages as possible. Chef then gets to eat the remaining cupcakes. Chef enjoys eating cupcakes very much. Help Chef choose the package size A that will let him eat as many cupcakes as possible.\n\n\nInput\n\nInput begins with an integer T, the number of test cases. Each test case consists of a single integer N, the number of cupcakes.\n\n\nOutput\n\nFor each test case, output the package size that will maximize the number of leftover cupcakes. If multiple package sizes will result in the same number of leftover cupcakes, print the largest such size.\n\n\nConstraints\n\n1 \u2264 T \u2264 1000\n2 \u2264 N \u2264 100000000 (10^8)\n\n\nSample Input\n2\n2\n5\n\nSample Output\n2\n3\n\nExplanation\n\nIn the first test case, there will be no leftover cupcakes regardless of the size Chef chooses, so he chooses the largest possible size.  In the second test case, there will be 2 leftover cupcakes.\n\n### Signature\ndef solve_problem(input_str: str) -> str:",
        "timestamp": "2025-10-16T20:59:19.457408",
        "response_time": "3.17",
        "context": "{\"function_name\": \"solve_problem\", \"difficulty\": 1, \"difficulty_label\": \"EASY\"}"
    },
    {
        "dataset_name": "code_contests_chatgpt4o",
        "dataset_row_id": 5.0,
        "solution": "```python\n===START===\ndef solve_problem(input_str: str) -> str:\n    input_lines = input_str.strip().split(\"\\n\")\n    T = int(input_lines[0])  # Number of test cases\n    results = []\n    index = 1\n\n    for _ in range(T):\n        # Read N, K, and initial Answer\n        N, K, Answer = map(int, input_lines[index].split())\n        index += 1\n\n        # Read array A\n        A = list(map(int, input_lines[index].split()))\n        index += 1\n\n        # Read Operator\n        Operator = input_lines[index]\n        index += 1\n\n        # Perform the operation\n        if Operator == \"XOR\":\n            for _ in range(K):\n                for a in A:\n                    Answer ^= a\n        elif Operator == \"AND\":\n            for _ in range(K):\n                for a in A:\n                    Answer &= a\n        elif Operator == \"OR\":\n            for _ in range(K):\n                for a in A:\n                    Answer |= a\n\n        results.append(str(Answer))\n\n    return \"\\n\".join(results)\n===END===\n```",
        "llm_name": "openai/gpt-4o-2024-11-20",
        "prompt": "### Prompt\nYou are given a simple code of a function and you would like to know what it will return. \n\n F(N, K, Answer, Operator, A[N]) returns int;\n  begin\n      for iK do\n         for jN do\n            AnswerAnswer operator Aj)\n       return Answer\n  end\n\n\nHere N, K, Answer and the value returned by the function F are integers; A is an array of N integers numbered from 1 to N; Operator can be one of the binary operators XOR, AND or OR. If you are not familiar with these terms then better have a look at following articles: XOR, OR, AND.\n\nInput\nThe first line of input contains an integer T - the number of test cases in file. Description of each test case consists of three lines. The first one contains three integers N, K and initial Answer. Array A is given in the second line and Operator is situated on the third one. Operators are given as strings, of capital letters. It is guaranteed that there will be no whitespaces before or after Operator. \n\nOutput\nOutput one line for each test case - the value that is returned by described function with given arguments.\n\nConstraints\n\n1\u2264T\u2264100\n1\u2264N\u22641000\n0\u2264Answer, K, Ai\u226410^9\n Operator is one of these: \"AND\", \"XOR\", \"OR\".\n\n\nExample\nInput:\n3\n3 1 0\n1 2 3\nXOR\n3 1 0\n1 2 3\nAND\n3 1 0\n1 2 3\nOR\nOutput:\n0\n0\n3\n\u00a0\n\nExplanation\n\n0 xor 1 xor 2 xor 3 = 0\n0 and 1 and 2 and 3 = 0\n0 or 1 or 2 or 3 = 3\n\n### Signature\ndef solve_problem(input_str: str) -> str:",
        "timestamp": "2025-10-16T20:59:23.824898",
        "response_time": "4.37",
        "context": "{\"function_name\": \"solve_problem\", \"difficulty\": 2, \"difficulty_label\": \"MEDIUM\"}"
    },
    {
        "dataset_name": "code_contests_chatgpt4o",
        "dataset_row_id": 6.0,
        "solution": "```python\n===START===\ndef solve_problem(input_str: str) -> str:\n    def is_valid_velocity(start_velocity, attractiveness):\n        current_velocity = start_velocity\n        for w in attractiveness:\n            if current_velocity < w:\n                return False\n            current_velocity -= 1\n        return True\n\n    input_lines = input_str.strip().split(\"\\n\")\n    T = int(input_lines[0])  # Number of test cases\n    results = []\n    index = 1\n\n    for _ in range(T):\n        N = int(input_lines[index])  # Number of segments\n        attractiveness = list(map(int, input_lines[index + 1].split()))\n        index += 2\n\n        # Binary search to find the minimal starting velocity\n        low, high = 1, max(attractiveness)\n        while low < high:\n            mid = (low + high) // 2\n            if is_valid_velocity(mid, attractiveness):\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(str(low))\n\n    return \"\\n\".join(results)\n===END===\n```",
        "llm_name": "openai/gpt-4o-2024-11-20",
        "prompt": "### Prompt\nChef and his girlfriend are going to have a promenade. They are walking along the straight road which consists of segments placed one by one. Before walking Chef and his girlfriend stay at the beginning of the first segment, they want to achieve the end of the last segment. \nThere are few problems: \n\n At the beginning Chef should choose constant integer - the velocity of mooving. It can't be changed inside one segment. \n The velocity should be decreased by at least 1 after achieving the end of some segment. \n There is exactly one shop on each segment. Each shop has an attractiveness. If it's attractiveness is W and Chef and his girlfriend move with velocity V then if V < W girlfriend will run away into the shop and the promenade will become ruined. \n\n Chef doesn't want to lose her girl in such a way, but he is an old one, so you should find the minimal possible velocity at the first segment to satisfy all conditions.\n\u00a0\n\n\nInput\n\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\nThe first line of each test case contains a single integer N denoting the number of segments. The second line contains N space-separated integers W1, W2, ..., WN denoting the attractiveness of shops. \n\n\u00a0\n\nOutput\n\nFor each test case, output a single line containing the minimal possible velocity at the beginning.\n\n\u00a0\n\nConstraints\n\n1 \u2264 T \u2264 10\n1 \u2264 N \u2264 10^5\n1 \u2264 Wi \u2264 10^6\n\n\u00a0\n\nExample\nInput:\n\n2\n5\n6 5 4 3 2\n5\n3 4 3 1 1\n\nOutput:\n\n6\n5\n\u00a0\n\nExplanation\nExample case 1. \n If we choose velocity 6, on the first step we have 6 \u2265 6 everything is OK, then we should decrease the velocity to 5 and on the 2nd segment we'll receive 5 \u2265 5, again OK, and so on. \nExample case 2. \n If we choose velocity 4, the promanade will be ruined on the 2nd step (we sould decrease our velocity, so the maximal possible will be 3 which is less than 4).\n\n### Signature\ndef solve_problem(input_str: str) -> str:",
        "timestamp": "2025-10-16T20:59:29.081792",
        "response_time": "5.25",
        "context": "{\"function_name\": \"solve_problem\", \"difficulty\": 2, \"difficulty_label\": \"MEDIUM\"}"
    },
    {
        "dataset_name": "code_contests_chatgpt4o",
        "dataset_row_id": 7.0,
        "solution": "```python\n===START===\nfrom math import factorial\nfrom fractions import Fraction\n\ndef solve_problem(input_str: str) -> str:\n    def expected_shuffles(n):\n        # Precompute factorials\n        fact = [1] * (n + 1)\n        for i in range(2, n + 1):\n            fact[i] = fact[i - 1] * i\n\n        # Precompute probabilities\n        dp = [Fraction(0)] * (n + 1)\n        dp[0] = Fraction(0)  # Base case: 0 elements need 0 shuffles\n        dp[1] = Fraction(0)  # Base case: 1 element is already sorted\n\n        for k in range(2, n + 1):\n            total_permutations = fact[k]\n            expected = Fraction(0)\n            for fixed in range(k + 1):\n                # Number of permutations where `fixed` elements are in the correct position\n                correct_permutations = fact[k] // (fact[fixed] * fact[k - fixed])\n                # Remaining elements to sort\n                remaining = k - fixed\n                expected += Fraction(correct_permutations, total_permutations) * (1 + dp[remaining])\n            dp[k] = expected\n\n        return dp[n]\n\n    # Parse input\n    lines = input_str.strip().split(\"\\n\")\n    t = int(lines[0])\n    test_cases = [int(lines[i]) for i in range(1, t + 1)]\n\n    # Compute results\n    results = []\n    for n in test_cases:\n        result = expected_shuffles(n)\n        results.append(f\"{result.numerator}/{result.denominator}\")\n\n    return \"\\n\".join(results)\n===END===\n```",
        "llm_name": "openai/gpt-4o-2024-11-20",
        "prompt": "### Prompt\nRecently Johnny have learned bogosort sorting algorithm. He thought that it is too ineffective. So he decided to improve it. As you may know this algorithm shuffles the sequence randomly until it is sorted. Johnny decided that we don't need to shuffle the whole sequence every time. If after the last shuffle several first elements end up in the right places we will fix them and don't shuffle those elements furthermore. We will do the same for the last elements if they are in the right places. For example, if the initial sequence is (3, 5, 1, 6, 4, 2) and after one shuffle Johnny gets (1, 2, 5, 4, 3, 6) he will fix 1, 2 and 6 and proceed with sorting (5, 4, 3) using the same algorithm. Johnny hopes that this optimization will significantly improve the algorithm. Help him calculate the expected amount of shuffles for the improved algorithm to sort the sequence of the first n natural numbers given that no elements are in the right places initially.\n\nInput\nThe first line of input file is number t - the number of test cases. Each of the following t lines hold single number n - the number of elements in the sequence.\n\n\nConstraints\n1 <= t <= 150\n2 <= n <= 150\n\n\nOutput\nFor each test case output the expected amount of shuffles needed for the improved algorithm to sort the sequence of first n natural numbers in the form of irreducible fractions.\n\n\nExample\n\nInput:\n3\n2\n6\n10\n\nOutput:\n2\n1826/189\n877318/35343\n\n### Signature\ndef solve_problem(input_str: str) -> str:",
        "timestamp": "2025-10-16T20:59:41.823784",
        "response_time": "12.74",
        "context": "{\"function_name\": \"solve_problem\", \"difficulty\": 2, \"difficulty_label\": \"MEDIUM\"}"
    },
    {
        "dataset_name": "code_contests_chatgpt4o",
        "dataset_row_id": 8.0,
        "solution": "```python\n===START===\nfrom itertools import combinations\n\ndef solve_problem(input_str: str) -> str:\n    input_lines = input_str.strip().split(\"\\n\")\n    T = int(input_lines[0])  # Number of test cases\n    results = []\n    idx = 1\n\n    for _ in range(T):\n        # Read N, M, K\n        N, M, K = map(int, input_lines[idx].split())\n        idx += 1\n\n        # Read initial colors\n        A = list(map(int, input_lines[idx].split()))\n        idx += 1\n\n        # Read Bi,j (points received for painting cell i with color j)\n        B = []\n        for i in range(N):\n            B.append(list(map(int, input_lines[idx].split())))\n            idx += 1\n\n        # Read Ci,j (cost of painting cell i with color j)\n        C = []\n        for i in range(N):\n            C.append(list(map(int, input_lines[idx].split())))\n            idx += 1\n\n        # Calculate the maximum points\n        dp = [[-float('inf')] * (K + 1) for _ in range(N + 1)]\n        dp[0][0] = 0  # Base case: no cells, no repaintings, 0 points\n\n        for i in range(1, N + 1):\n            for k in range(K + 1):\n                # Case 1: Do not repaint cell i\n                current_color = A[i - 1] - 1  # Convert 1-based to 0-based index\n                dp[i][k] = max(dp[i][k], dp[i - 1][k] + B[i - 1][current_color])\n\n                # Case 2: Repaint cell i with a different color\n                if k > 0:\n                    for color in range(M):\n                        if color != current_color:  # Only consider repainting to a different color\n                            gain = B[i - 1][color] - C[i - 1][color]\n                            dp[i][k] = max(dp[i][k], dp[i - 1][k - 1] + gain)\n\n        # The answer for this test case is the maximum points we can achieve with at most K repaintings\n        results.append(max(dp[N]))\n\n    return \"\\n\".join(map(str, results))\n===END===\n```",
        "llm_name": "openai/gpt-4o-2024-11-20",
        "prompt": "### Prompt\nChef had a hard time arguing with his friend, and after getting a great old kick Chef saw a colored array with N cells, numbered from 1 to N. \nThe kick was so strong that Chef suddenly understood the rules of the game. \n\nEach cell is painted with a color. Here the colors are numbered from 1 to M.\nFor any cell i, Chef can repaint it with any color q, and the cost of such operation is Ci,q points.\nHowever Chef can do at most K repaintings (0 repaintings is possible). \nAfter performing all repaintings, each cell will have some color. For each cell i, if cell i has color q then Chef will receive Bi,q points.\n\nNow Chef is wondering how many points can he receive in total when he repaints optimally.\n\nInput\nThe first line of the input contains an integer T, denoting the number of test cases. The description of T test cases follows.\nThe first line of each test case contains three space-separated integers N, M and K, denoting the number of cells and the number of colors, the maximal possible number of repaintings respectively. The next line contains N space-separated integers A1, A2, ..., AN, denoting the initial colors of the cells. Then N lines follow. The i^th line of them contains M integers Bi1, Bi2, ..., BiM, where Bij denotes how many points Chef will receive if the cell i will be painted with j-th color after all operations. Then N lines follow. The i^th line  of them contains M integers Ci1, Ci2, ..., CiM, where Cij denotes how many points Chef will lose if he repaints the cell i with color j.\n\nNote: Be careful that the size of input files can be large.\n\n\nOutput\nFor each test case, output a single line containing the maximal possible points.\n\nConstraints\n\n1 \u2264 T \u2264 5\n0 \u2264 K \u2264 1000\n1 \u2264 N, M \u2264 1000\n1 \u2264 Ai \u2264 M\n0 \u2264 Bi,j \u2264 1000\n0 \u2264 Ci,j \u2264 1000\nIf j = Ai, then Ci,j = 0\n\n\nExample\nInput:\n1\n4 2 1\n1 1 2 2\n1 1\n1 1\n1 1\n3 1\n0 1\n0 1\n1 0\n1 0\n\nOutput:\n5\n\nExplanation:\n For this sample, we can repaint only once, since K = 1. We should repaint 4^th cell with color 1. We will pay 1 for this, and receive: \n1 (1^st cell - 1^st color) + \n1 (2^nd cell -1^st color) + \n1 (3^rd cell - 2^nd color) + \n3 (4^th cell - 1^st color)  = 6.\nHence we get 6 \u2212 1 = 5 points in total, and it is the optimal answer.\n\n### Signature\ndef solve_problem(input_str: str) -> str:",
        "timestamp": "2025-10-16T20:59:52.533458",
        "response_time": "10.71",
        "context": "{\"function_name\": \"solve_problem\", \"difficulty\": 2, \"difficulty_label\": \"MEDIUM\"}"
    },
    {
        "dataset_name": "code_contests_chatgpt4o",
        "dataset_row_id": 9.0,
        "solution": "```python\n===START===\nfrom math import gcd\n\ndef solve_problem(input_str: str) -> str:\n    def can_first_player_win(pairs):\n        # Calculate the Grundy number for each pair\n        grundy = 0\n        for a, b in pairs:\n            while a != b:\n                if a > b:\n                    a %= b\n                    if a == 0:\n                        a = b\n                else:\n                    b %= a\n                    if b == 0:\n                        b = a\n            grundy ^= a  # XOR the final value (GCD of the pair)\n        return grundy != 0\n\n    # Parse input\n    lines = input_str.strip().split(\"\\n\")\n    T = int(lines[0])\n    results = []\n    idx = 1\n    for _ in range(T):\n        N = int(lines[idx])\n        idx += 1\n        pairs = []\n        for __ in range(N):\n            a, b = map(int, lines[idx].split())\n            pairs.append((a, b))\n            idx += 1\n        # Determine if the first player can win\n        if can_first_player_win(pairs):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return \"\\n\".join(results)\n===END===\n```",
        "llm_name": "openai/gpt-4o-2024-11-20",
        "prompt": "### Prompt\nTwo players are playing a game. The game is played on a sequence of positive integer pairs. The players make their moves alternatively. During his move the player chooses a pair and decreases the larger integer in the pair by a positive multiple of the smaller integer in the pair in such a way that both integers in the pair remain positive. If two numbers in some pair become equal then the pair is removed from the sequence. The player who can not make any move loses (or in another words the player who encounters an empty sequence loses). Given the sequence of positive integer pairs determine whether the first player can win or not (assuming that both players are playing optimally).\n\nInput\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\nEach test starts with an integer N denoting the number of pairs. Each of the next N lines contains a pair of positive integers. \n\u00a0\n\nOutput\nFor each test case, output a single line containing \"YES\" if the first player can win and \"NO\" otherwise. \n\nConstraints\n\n1 \u2264 T \u2264 100\n1 \u2264 N \u2264 100\nAll other integers are between 1 to 10^8\nThe integers in each pair will be different\n\n\u00a0\n\nExample\nInput:\n3\n1\n2 3\n2\n4 5\n5 6\n2\n2 3\n3 5\n\nOutput:\nNO\nNO\nYES\n\n\u00a0\n\nExplanation\nExample case 1. The first player don't have any choice other subtracting 2 from 3. So during the turn of the second player integer pair will be (2,1). The second player will win by subtracting 1 from 2. \nExample case 2. If the first player choose to move (4,5) to (4,1) the second player will make it to (1,1). If the first player choose to move (5,6) to (5,1) the second player will make it to (1,1). So regardless of the move of the first player, the second will always win.\nExample case 3. The first player will select pair (3,5) and make it to (3,2). Now both pairs are equal. So whatever the move of second player he will just mirror that move in another pair. This will ensure his win.\n\n### Signature\ndef solve_problem(input_str: str) -> str:",
        "timestamp": "2025-10-16T20:59:58.164662",
        "response_time": "5.63",
        "context": "{\"function_name\": \"solve_problem\", \"difficulty\": 2, \"difficulty_label\": \"MEDIUM\"}"
    },
    {
        "dataset_name": "code_contests_chatgpt4o",
        "dataset_row_id": 10.0,
        "solution": "```python\n===START===\ndef solve_problem(input_str: str) -> str:\n    def is_lucky(num_str):\n        \"\"\"Check if a number is lucky (contains only digits 4 and 7).\"\"\"\n        return all(c in '47' for c in num_str)\n    \n    def min_operations_to_lucky(num_str):\n        \"\"\"Calculate the minimum operations to convert num_str to a lucky number.\"\"\"\n        n = len(num_str)\n        min_operations = float('inf')\n        \n        # Generate all possible lucky numbers of the same length or one more digit\n        for length in (n, n + 1):\n            for lucky_candidate in generate_lucky_numbers(length):\n                # Calculate the number of operations to convert num_str to lucky_candidate\n                operations = calculate_operations(num_str, lucky_candidate)\n                min_operations = min(min_operations, operations)\n        \n        return min_operations\n    \n    def generate_lucky_numbers(length):\n        \"\"\"Generate all lucky numbers of a given length.\"\"\"\n        if length == 0:\n            return [\"\"]\n        smaller_lucky_numbers = generate_lucky_numbers(length - 1)\n        return [num + '4' for num in smaller_lucky_numbers] + [num + '7' for num in smaller_lucky_numbers]\n    \n    def calculate_operations(original, target):\n        \"\"\"Calculate the number of operations to convert original to target.\"\"\"\n        # Pad the shorter number with leading zeros\n        if len(original) < len(target):\n            original = '0' * (len(target) - len(original)) + original\n        elif len(target) < len(original):\n            target = '0' * (len(original) - len(target)) + target\n        \n        # Count the number of differing digits\n        operations = 0\n        for o, t in zip(original, target):\n            if o != t:\n                operations += 1\n        \n        return operations\n    \n    # Parse input\n    lines = input_str.strip().split('\\n')\n    T = int(lines[0])\n    results = []\n    \n    for i in range(1, T + 1):\n        N = lines[i]\n        if is_lucky(N):\n            results.append(0)\n        else:\n            results.append(min_operations_to_lucky(N))\n    \n    return '\\n'.join(map(str, results))\n===END===\n```",
        "llm_name": "openai/gpt-4o-2024-11-20",
        "prompt": "### Prompt\nChef loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.\n\n Chef has a positive integer N. He can apply any of the following operations as many times as he want in any order:\n\n\n Add 1 to the number N.\n Take some digit of N and replace it by any non-zero digit.\n Add any non-zero leading digit to N.\n\n Find the minimum number of operations that is needed for changing N to the lucky number.\n\n\nInput\nThe first line contains a single positive integer T, the number of test cases. T test cases follow. The only line of each test case contains a positive integer N without leading zeros. \n\n\nOutput\nFor each T test cases print one integer, the minimum number of operations that is needed for changing N to the lucky number.\n\n\nConstraints\n\n1 \u2264 T \u2264 10\n\n1 \u2264 N < 10^100000\n\nExample\n\nInput:\n3\n25\n46\n99\n\nOutput:\n2\n1\n2\n\n### Signature\ndef solve_problem(input_str: str) -> str:",
        "timestamp": "2025-10-16T21:00:05.787827",
        "response_time": "7.62",
        "context": "{\"function_name\": \"solve_problem\", \"difficulty\": 2, \"difficulty_label\": \"MEDIUM\"}"
    },
    {
        "dataset_name": "code_contests_chatgpt4o",
        "dataset_row_id": 11.0,
        "solution": "```python\n===START===\nfrom itertools import permutations\n\ndef solve_problem(input_str: str) -> str:\n    # Parse the input\n    lines = input_str.strip().split(\"\\n\")\n    N = int(lines[0])\n    digits = list(map(int, lines[1].split()))\n    \n    # Helper function to check if a number has leading zeros\n    def has_leading_zeros(num_str):\n        return len(num_str) > 1 and num_str[0] == '0'\n    \n    # Helper function to check if a multiplication is valid\n    def is_valid_multiplication(a, b, digits_set):\n        # Calculate the partial products and the final product\n        partial1 = a * (b % 10)  # Last digit of b\n        partial2 = a * (b // 10)  # First digit of b\n        product = a * b\n        \n        # Convert all numbers to strings\n        partial1_str = str(partial1)\n        partial2_str = str(partial2)\n        product_str = str(product)\n        \n        # Check for leading zeros\n        if has_leading_zeros(partial1_str) or has_leading_zeros(partial2_str) or has_leading_zeros(product_str):\n            return False\n        \n        # Check the lengths of the numbers\n        if len(partial1_str) != 3 or len(partial2_str) != 3 or len(product_str) != 4:\n            return False\n        \n        # Check if all digits are in the allowed set\n        all_digits = partial1_str + partial2_str + product_str\n        if not all(int(d) in digits_set for d in all_digits):\n            return False\n        \n        return True\n    \n    # Convert the digits list to a set for quick lookup\n    digits_set = set(digits)\n    \n    # Generate all permutations of the digits for the 3-digit and 2-digit numbers\n    three_digit_permutations = permutations(digits, 3)\n    two_digit_permutations = permutations(digits, 2)\n    \n    # Count the number of valid solutions\n    valid_count = 0\n    for three_digit in three_digit_permutations:\n        a = int(\"\".join(map(str, three_digit)))\n        for two_digit in two_digit_permutations:\n            b = int(\"\".join(map(str, two_digit)))\n            if is_valid_multiplication(a, b, digits_set):\n                valid_count += 1\n    \n    # Return the result as a string\n    return str(valid_count)\n===END===\n```",
        "llm_name": "openai/gpt-4o-2024-11-20",
        "prompt": "### Prompt\nIn PrimeLand, there existed a very handsome young prince named Prima. He greatly desired the Princess of Mathematics \u2013 Facie. However, before accepting his hand in marriage, Facie asked Prima to solve the following problem:\n\n\nThe figure below shows a simple multiplication problem. However, not all the decimal digits are available. Prima has to find an assignment of digits to the marked places so that the multiplication is valid.\n\n\n      * * *\n   x    * *\n    -------\n      * * *         <-- partial product 1\n    * * *           <-- partial product 2\n    -------\n    * * * *\n\n\nDigits can appear only in places marked by `*'. Of course, leading zeroes are not allowed.\nWrite a program to help Prima that will find all solutions to this problem for any subset of digits from the set {1,2,3,4,5,6,7,8,9}.\n\n\n\nInput\nThe first line contains N, the number of digits that will be used \nThe second line contains N space separated digits \n\n\nOutput\nA single line with the total number of unique solutions. Here is the single solution for the sample input:\n\n      2 2 2\n    x   2 2\n     ------\n      4 4 4\n    4 4 4\n  ---------\n    4 8 8 4\n\n\nExample\n\nInput:\n5\n2 3 4 6 8\n\n\nOutput:\n1\n\n### Signature\ndef solve_problem(input_str: str) -> str:",
        "timestamp": "2025-10-16T21:00:22.563763",
        "response_time": "16.77",
        "context": "{\"function_name\": \"solve_problem\", \"difficulty\": 3, \"difficulty_label\": \"HARD\"}"
    },
    {
        "dataset_name": "code_contests_chatgpt4o",
        "dataset_row_id": 12.0,
        "solution": "```python\n===START===\ndef solve_problem(input_str: str) -> str:\n    input_lines = input_str.splitlines()\n    T = int(input_lines[0])  # Number of test cases\n    results = []\n    \n    for i in range(1, T + 1):\n        N = int(input_lines[i])\n        # The total distance walked can be calculated as:\n        # 2 * (N + (N-1) + (N-2) + ... + 1) = 2 * (N * (N + 1) // 2) - N\n        total_distance = N * (N + 1) - N\n        results.append(total_distance)\n    \n    return \"\\n\".join(map(str, results))\n===END===\n```",
        "llm_name": "openai/gpt-4o-2024-11-20",
        "prompt": "### Prompt\nThere are N+1 lights. Lights are placed at  (0, 0), (1, 0), (2, 0) ... (N, 0). Initially all the lights are on. You want to turn off all of them one after one.  You want to follow a special pattern in turning off the lights.\n\n\nYou will start at (0, 0). First, you walk to the right most light that is on, turn it off. Then you walk to the left most light that is on, turn it off. Then again to the right most light that is on and so on. You will stop after turning off all lights. You want to know how much distance you walked in the process. Note that distance between (a,0) and (b,0) is |a-b|.\n\n\nInput\nThe first line of the input contains an integer T denoting the number of test cases. Each test case has a single integer N on separate line.\n\n\nOutput\nFor each test case, output the distance you walked.\n\nConstraints\n\n1 \u2264 T \u2264 10^5\n1 \u2264 N \u2264 10^5\n\n\nExample\nInput\n2\n1\n2\n\nOutput\n2\n5\n\nExplanation\nTestcase #2\nYou are initially at (0, 0)\nRight most on-light is (2, 0). Distance = 2.\nNow you are at (2, 0).\nLeft most on-light is (0, 0). Distance = 2.\nNow you are at (0, 0)\nRight most on-light is (1, 0). Distance = 1.\nNow you are at (1, 0) and all lights are turned off.\nTotal distance walked = 5.\n\n### Signature\ndef solve_problem(input_str: str) -> str:",
        "timestamp": "2025-10-16T21:00:33.256115",
        "response_time": "10.69",
        "context": "{\"function_name\": \"solve_problem\", \"difficulty\": 2, \"difficulty_label\": \"MEDIUM\"}"
    },
    {
        "dataset_name": "code_contests_chatgpt4o",
        "dataset_row_id": 13.0,
        "solution": "```python\n===START===\ndef solve_problem(input_str: str) -> str:\n    MOD = 1000000007\n\n    def calculate_sum_after_m_minutes(N, m, x, y, A):\n        # Precompute the number of elements in the array after m minutes\n        size_after_m = N * (2 ** m) - (2 ** m - 1)\n        \n        # If the range x to y is outside the bounds of the array after m minutes, return 0\n        if x > size_after_m or y > size_after_m:\n            return 0\n        \n        # Precompute the prefix sums for the array after m minutes\n        prefix_sums = [0] * (size_after_m + 1)\n        current_array = A[:]\n        \n        for minute in range(m):\n            new_array = []\n            for i in range(len(current_array) - 1):\n                new_array.append(current_array[i])\n                new_array.append(current_array[i] + current_array[i + 1])\n            new_array.append(current_array[-1])\n            current_array = new_array\n        \n        # Compute the prefix sums\n        for i in range(1, size_after_m + 1):\n            prefix_sums[i] = (prefix_sums[i - 1] + current_array[i - 1]) % MOD\n        \n        # Return the sum of elements between x and y (1-based indexing)\n        return (prefix_sums[y] - prefix_sums[x - 1]) % MOD\n\n    # Parse the input\n    lines = input_str.strip().split(\"\\n\")\n    T = int(lines[0])\n    results = []\n    index = 1\n    \n    for _ in range(T):\n        N, m, x, y = map(int, lines[index].split())\n        A = list(map(int, lines[index + 1].split()))\n        index += 2\n        \n        # Calculate the result for this test case\n        result = calculate_sum_after_m_minutes(N, m, x, y, A)\n        results.append(result)\n    \n    # Return the results as a newline-separated string\n    return \"\\n\".join(map(str, results))\n===END===\n```",
        "llm_name": "openai/gpt-4o-2024-11-20",
        "prompt": "### Prompt\nChef has a an array A consisting of N elements. He wants to add some elements into the array as per the below mentioned process.\nAfter each minute, Chef iterates over the array in order from left to right, and takes every two neighbouring pair of elements, say x and y, he adds a new element x + y in the middle of elements x and y.\nFor example, if initial array A = {1, 6, 9}.\n\nAfter first minute, the array A will be equal to {1, 7, 6, 15, 9}. Please note that the elements shown in the bold font are the newly added elements during first minute. As you can observe that 7 = 1 + 6, and 15 = 6 + 9.\nAfter second minute, the array will be {1, 8, 7, 13, 6, 21, 15, 24, 9}. Once again, elements added during the second minute, are shown in bold. \n\nChef wants to know the sum of elements between x^th and y^th positions in the array A (i.e. Ax + Ax + 1 + ... + Ay) after m minutes. As the answer could be large, output it modulo 10^9+7 (1000000007). Please note that we use 1 based indexing in the problem.\n\nInput\n\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\nThe first line of each test case contains four space-separated integers N, m, x, y denoting the number of elements in the array A in the beginning, amount of minutes and range for finding sum.\nThe second line contains N space-separated integers A1, A2, ..., AN denoting the array A in the beginning. \n\n\nOutput\n\nFor each test case, output a single line containing an integer corresponding to the sum of elements between x^th and y^th positions in the array A after m minutes modulo 10^9+7.\n\n\nConstraints\n\n1 \u2264 T \u2264 10\n1 \u2264 N \u2264 10^5\n1 \u2264 Ai \u2264 10^3\n1 \u2264 m \u2264 30\n1 \u2264 x \u2264 y \u2264 size of the array A (|A|) after m minutes\n\n\nExample\nInput:\r\n2\r\n3 1 1 5\r\n1 6 9\r\n3 2 6 7\r\n1 6 9\r\n\r\nOutput:\r\n38\r\n36\r\n\n\nExplanation\nExample case 1. After the first minute A = {1, 7, 6, 15, 9} and sum of all elements will be 38.\nExample case 2. After the second minute the array A will be {1, 8, 7, 13, 6, 21, 15, 24, 9} and sum of elements between 6^th and 7^th equals to 21 + 15 = 36.\n\n### Signature\ndef solve_problem(input_str: str) -> str:",
        "timestamp": "2025-10-16T21:00:48.873125",
        "response_time": "15.61",
        "context": "{\"function_name\": \"solve_problem\", \"difficulty\": 3, \"difficulty_label\": \"HARD\"}"
    },
    {
        "dataset_name": "code_contests_chatgpt4o",
        "dataset_row_id": 14.0,
        "solution": "```python\n===START===\ndef solve_problem(input_str: str) -> str:\n    input_lines = input_str.strip().split(\"\\n\")\n    T = int(input_lines[0])  # Number of test cases\n    results = []\n    index = 1\n\n    for _ in range(T):\n        # Read activities and origin\n        activities, origin = input_lines[index].split()\n        activities = int(activities)\n        index += 1\n\n        # Initialize total laddus\n        total_laddus = 0\n\n        # Process each activity\n        for _ in range(activities):\n            activity = input_lines[index].split()\n            index += 1\n\n            if activity[0] == \"CONTEST_WON\":\n                rank = int(activity[1])\n                bonus = max(0, 20 - rank)\n                total_laddus += 300 + bonus\n            elif activity[0] == \"TOP_CONTRIBUTOR\":\n                total_laddus += 300\n            elif activity[0] == \"BUG_FOUND\":\n                severity = int(activity[1])\n                total_laddus += severity\n            elif activity[0] == \"CONTEST_HOSTED\":\n                total_laddus += 50\n\n        # Determine minimum laddus required per month\n        min_laddus_per_month = 200 if origin == \"INDIAN\" else 400\n\n        # Calculate maximum number of months\n        max_months = total_laddus // min_laddus_per_month\n        results.append(str(max_months))\n\n    return \"\\n\".join(results)\n===END===\n```",
        "llm_name": "openai/gpt-4o-2024-11-20",
        "prompt": "### Prompt\nYou might have heard about our new goodie distribution program aka the \"Laddu Accrual System\". This problem is designed to give you a glimpse of its rules. You can read the page once before attempting the problem if you wish, nonetheless we will be providing all the information needed here itself.\n\n\nLaddu Accrual System is our new goodie distribution program. In this program, we will be distributing Laddus in place of goodies for your winnings and various other activities (described below), that you perform on our system. Once you collect enough number of Laddus, you can then redeem them to get yourself anything from a wide range of CodeChef goodies.\n\n\nLet us know about various activities and amount of laddus you get corresponding to them.\n\nContest Win (CodeChef\u2019s Long, Cook-Off, LTIME, or any contest hosted with us) : 300 + Bonus (Bonus = 20 - contest rank). Note that if your rank is > 20, then you won't get any bonus.\nTop Contributor on Discuss : 300\nBug Finder\t: 50 - 1000 (depending on the bug severity). It may also fetch you a CodeChef internship! \nContest Hosting\t : 50 \n\n\nYou can do a checkout for redeeming laddus once a month. The minimum laddus redeemable at Check Out are 200 for Indians and 400 for the rest of the world.\n\n\nYou are given history of various activities of a user. The user has not redeemed any of the its laddus accrued.. Now the user just wants to redeem as less amount of laddus he/she can, so that the laddus can last for as long as possible. Find out for how many maximum number of months he can redeem the laddus.\n\n\nInput\n\nThe first line of input contains a single integer T denoting number of test cases\nFor each test case:\n\nFirst line contains an integer followed by a string denoting activities, origin respectively, where activities denotes number of activities of the user, origin denotes whether the user is Indian or the rest of the world. origin can be \"INDIAN\" or \"NON_INDIAN\".\nFor each of the next activities lines, each line contains an activity. \n\t\t\tAn activity can be of four types as defined above. \n\nContest Win : Input will be of form of CONTEST_WON rank, where rank denotes the rank of the user. \nTop Contributor : Input will be of form of TOP_CONTRIBUTOR.\nBug Finder : Input will be of form of BUG_FOUND severity, where severity denotes the severity of the bug. \nContest Hosting : Input will be of form of CONTEST_HOSTED.\n\n\n\n\n\n\nOutput\n\nFor each test case, find out the maximum number of months for which the user can redeem the laddus accrued.\n\n\nConstraints\n\n1 \u2264 T, activities \u2264 100\n1 \u2264 rank \u2264 5000\n50 \u2264 severity \u2264 1000\n\n\nExample\nInput:\n2\n4 INDIAN\nCONTEST_WON 1\nTOP_CONTRIBUTOR\nBUG_FOUND 100\nCONTEST_HOSTED\n4 NON_INDIAN\nCONTEST_WON 1\nTOP_CONTRIBUTOR\nBUG_FOUND 100\nCONTEST_HOSTED\n\nOutput:\n3\n1\n\nExplanation\nIn the first example, \n\nFor winning contest with rank 1, user gets 300 + 20 - 1 = 319 laddus. \nFor top contributor, user gets 300 laddus. \nFor finding a bug with severity of 100, user gets 100 laddus. \nFor hosting a contest, user gets 50 laddus. \n\n\nSo, overall user gets 319 + 300 + 100 + 50 = 769 laddus.\nNow, the user is an Indian user, he can redeem only 200 laddus per month. So, for first three months, he will redeem 200 * 3 = 600 laddus. The remaining 169 laddus, he can not redeem as he requires at least 200 laddues in a month to redeem. \nSo, answer is 3.\n\nIn the second example, user is a non-Indian user, he can redeem 400 laddues per month. So, in the first month, he will redeem 400 laddus. The remaining 369 laddus, he can not redeem as he requires at least 400 laddues in a month to redeem. \nSo, answer is 1.\n\n### Signature\ndef solve_problem(input_str: str) -> str:",
        "timestamp": "2025-10-16T21:00:56.636388",
        "response_time": "7.76",
        "context": "{\"function_name\": \"solve_problem\", \"difficulty\": 1, \"difficulty_label\": \"EASY\"}"
    },
    {
        "dataset_name": "code_contests_chatgpt4o",
        "dataset_row_id": 15.0,
        "solution": "```python\n===START===\ndef solve_problem(input_str: str) -> str:\n    # Parse the input\n    lines = input_str.strip().split(\"\\n\")\n    N = int(lines[0])\n    events = []\n    \n    for i in range(1, N + 1):\n        S, D = map(int, lines[i].split())\n        events.append((S, S + D - 1))  # Store events as (start, end)\n    \n    # Sort events by their end time (primary) and start time (secondary)\n    events.sort(key=lambda x: (x[1], x[0]))\n    \n    # Greedy algorithm to select the maximum number of non-overlapping events\n    max_events = 0\n    last_end_time = 0\n    \n    for start, end in events:\n        if start > last_end_time:  # If the event does not overlap with the last selected event\n            max_events += 1\n            last_end_time = end  # Update the last end time\n    \n    return str(max_events)\n===END===\n```",
        "llm_name": "openai/gpt-4o-2024-11-20",
        "prompt": "### Prompt\nThe bustling town of Siruseri has just one sports stadium. There\nare a number of schools, colleges, sports associations, etc. that\nuse this stadium as the venue for their sports events. \n Anyone interested in using the stadium has to apply to the Manager\nof the stadium indicating both the starting date (a positive integer\nS) and the length of the sporting event in days (a positive integer D)\nthey plan to organise.  Since these requests could overlap it may not\nbe possible to satisfy everyone.  \n\nIt is the job of the Manager to decide who gets to use the\nstadium and who does not. The Manager, being a genial man, would like\nto keep as many organisations happy as possible and hence would\nlike to allocate the stadium so that maximum number of events are held.\n\n\nSuppose, for example, the Manager receives the following 4 requests: \n\n\n\nEvent No.\nStart Date\nLength\n\n125\n297\n3156\n493\n\n\nHe would allot the stadium to events 1, 4 and 3. Event 1 begins on day 2\nand ends on day 6, event 4 begins on day 9 and ends on day 11 and event\n3 begins on day 15 and ends on day 20. You can verify that it is not possible\nto schedule all the 4 events (since events 2 and 3 overlap  and only one of \nthem can get to use the stadium).\n\n\nYour task is to help the manager find the best possible allotment (i.e.,\nthe maximum number of events that can use the stadium).\n\nInput format\n\nThe first line of the input will contain a single integer N (N \u2264 100000)\nindicating the number of events for which the Manager has received a request.\nLines 2,3,...,N+1  describe the requirements of the N events.  \nLine i+1 contains two integer Si and Di indicating the starting date \nand the duration of event i. You may assume that 1 \u2264 Si \u2264 1000000 and \n1 \u2264 Di \u2264 1000.\n\n\nOutput format\n\nYour output must consist of a single line containing a single integer M,\nindicating the maximum possible number of events that can use the stadium.\n\nExample:\nSample input:\n\n4\n2 5\n9 7\n15 6\n9 3\n\nSample output:\n\n3\n\n### Signature\ndef solve_problem(input_str: str) -> str:",
        "timestamp": "2025-10-16T21:01:01.660792",
        "response_time": "5.02",
        "context": "{\"function_name\": \"solve_problem\", \"difficulty\": 3, \"difficulty_label\": \"HARD\"}"
    },
    {
        "dataset_name": "code_contests_chatgpt4o",
        "dataset_row_id": 16.0,
        "solution": "```python\n===START===\ndef solve_problem(input_str: str) -> str:\n    input_lines = input_str.strip().split(\"\\n\")\n    T = int(input_lines[0])  # Number of test cases\n    results = []\n    idx = 1\n    \n    for _ in range(T):\n        N = int(input_lines[idx])  # Number of different types of ingredients\n        idx += 1\n        A = list(map(int, input_lines[idx].split()))  # Quantities of each ingredient\n        idx += 1\n        \n        # Check if it's possible to get at least 2 units of each type\n        if any(a < 2 for a in A):\n            results.append(\"-1\")\n        else:\n            # In the worst case, she needs to pick all items\n            results.append(str(sum(A)))\n    \n    return \"\\n\".join(results)\n===END===\n```",
        "llm_name": "openai/gpt-4o-2024-11-20",
        "prompt": "### Prompt\nRupsa recently started to intern under Chef. He gave her N type of ingredients of varying quantity  A1, A2, ..., AN respectively to store it. But as she is lazy to arrange them she puts them all in a storage box.\nChef comes up with a new recipe and decides to prepare it. He asks Rupsa to get two units of each type ingredient for the dish. But when she went to retrieve the ingredients, she realizes that she can only pick one item at a time from the box and can know its type only after she has picked it out. The picked item is not put back in the bag.\nShe, being lazy, wants to know the maximum number of times she would need to pick items from the box in the worst case so that it is guaranteed that she gets at least two units of each type of ingredient. If it is impossible to pick items in such a way, print -1.\n\nInput\n\nThe first line of the input contains an integer T denoting the number of test cases.\nThe first line of each test case contains a single integer N denoting the number of different type of ingredients.\nThe second line contains N space-separated integers A1, A2, ..., AN denoting the quantity of each ingredient.\n\n\nOutput\n\nFor each test case, output a single line containing an integer denoting the answer corresponding to that test case.\n\n\nConstraints\n\n1 \u2264 T \u2264 10\n1 \u2264 N \u2264 10^5\n1 \u2264 Ai \u2264 10^4\n\n\nSub tasks\n\nExample\nInput:\n2\n2\n2 2\n1\n6\n\nOutput:\n4\n2\n\nExplanation\n\nIn Example 1, she need to pick up all items.\nIn Example 2, since there is only one type of ingredient, picking two items is enough.\n\n### Signature\ndef solve_problem(input_str: str) -> str:",
        "timestamp": "2025-10-16T21:01:05.248521",
        "response_time": "3.58",
        "context": "{\"function_name\": \"solve_problem\", \"difficulty\": 2, \"difficulty_label\": \"MEDIUM\"}"
    },
    {
        "dataset_name": "code_contests_chatgpt4o",
        "dataset_row_id": 17.0,
        "solution": "```python\n===START===\ndef solve_problem(input_str: str) -> str:\n    # Parse the input\n    lines = input_str.strip().split(\"\\n\")\n    T = int(lines[0])  # Number of test cases\n    results = []\n    idx = 1\n    \n    for _ in range(T):\n        # Read N and M\n        N, M = map(int, lines[idx].split())\n        idx += 1\n        # Read the chain sizes\n        chain_sizes = list(map(int, lines[idx].split()))\n        idx += 1\n        \n        # To connect M chains into one chain, we need (M - 1) cuts\n        results.append(M - 1)\n    \n    # Return the results as a newline-separated string\n    return \"\\n\".join(map(str, results))\n===END===\n```",
        "llm_name": "openai/gpt-4o-2024-11-20",
        "prompt": "### Prompt\nThere is new delicious item in Chef's menu - a doughnut chain. Doughnuts connected successively in line forming a chain.\n\n\nChain of 3 doughnuts\n\nChef has received an urgent order for making a chain of N doughnuts. He noticed that there are exactly N cooked doughnuts in the kitchen, some of which are already connected in chains. The only thing he needs to do is connect them in one chain.\nHe can cut one doughnut (from any position in a chain) into two halves and then use this cut doughnut to link two different chains.\nHelp Chef determine the minimum number of cuts needed to complete the order.\n\n\nInput\n\nThe first line of the input contains an integer T denoting the number of test cases.\nThe first line of each test case contains two integer N and M denoting the size of order and number of cooked chains respectively.\nThe second line contains M space-separated integers A1, A2, ..., AM denoting the size of the chains.\n\nIt is guaranteed that N is equal to the sum of all Ai's over 1<=i<=M.\n\nOutput\nFor each test case, output a single line containing an integer corresponding to the number of cuts needed Chef to make the order.\n\nConstraints and Example\nInput:\n2\n11 3\n4 3 4\n6 3\n3 2 1\n\nOutput:\n2\n1\n\n\nExplanation\nExample 1: We could cut 2 doughnut from any \"chain\" and use them to connect chains to the one.  For example, let's cut it from the first chain. After this we will have chains of sizes 2, 3, 4 and two doughnuts that have been cut. So we could connect the first chain with second and second with third using these two doughnuts.\nExample 2: We cut doughnut from the last \"chain\" and connect the first two chains.\n\nImage for second example. Yellow doughnut has been cut.\n\n### Signature\ndef solve_problem(input_str: str) -> str:",
        "timestamp": "2025-10-16T21:01:09.273091",
        "response_time": "4.02",
        "context": "{\"function_name\": \"solve_problem\", \"difficulty\": 2, \"difficulty_label\": \"MEDIUM\"}"
    },
    {
        "dataset_name": "code_contests_chatgpt4o",
        "dataset_row_id": 18.0,
        "solution": "```python\n===START===\nfrom math import comb\n\ndef solve_problem(input_str: str) -> str:\n    input_lines = input_str.strip().split(\"\\n\")\n    T = int(input_lines[0])\n    results = []\n    \n    for t in range(T):\n        R, C, G = map(int, input_lines[t + 1].split())\n        moves = []\n        current_coins = G\n        current_column = C\n        \n        while current_coins > 0:\n            for row in range(R, -1, -1):\n                if row >= current_column and comb(row, current_column) <= current_coins:\n                    coins_collected = comb(row, current_column)\n                    moves.append(coins_collected)\n                    current_coins -= coins_collected\n                    R = row - 1\n                    current_column -= 1\n                    break\n        \n        results.append(f\"{len(moves)}\")\n        results.append(\" \".join(map(str, moves)))\n    \n    return \"\\n\".join(results)\n===END===\n```",
        "llm_name": "openai/gpt-4o-2024-11-20",
        "prompt": "### Prompt\nThe much anticipated video game \"BiCo Grid\" has been released. The rules of \"Bico Grid\" are very simple.\nThe game field is a 100x100 matrix, where each cell is either a blocked cell, or a cell with some number of coins. For a regular player the look of the field seems pretty random, but the programmer in you recognizes the following pattern: the i-th cell on the n-th row contains C(n, i) coins if and only if 0 \u2264 i \u2264 n, all other cells are blocked. Record C(n, i) denotes binomial coefficient \"n choose i\".\nThe player starts from the cell situated at row R and column C in the matrix. The objective is to collect exactly G number of coins from matrix in several moves. There are some rules: \n\nOn each move the player must collect all the coins from some unblocked cell in the current column.\nThe rules of the game state, that player mustn't be really greedy, so the number of coins he collected must not increase. In other words, if at some move the player collected X coins then further he cannot collect more than X coins in a single move.\nAfter each move, the player is immediately moved to some cell of the column W-1 (where W denotes the current column of the player). If the current column of the player has index 0, the game ends.\nThe game ends when player collects exactly G number of coins.\n\nYou are given the description of the game. Please, output the sequence of moves that win the game (collect exactly G coins)! It is guaranteed that if the player will play optimally it is possible to win the game.\n\nInput\nThe first line of the input contains an integer T denoting the number of test cases. Then T lines follows. Each containing three integers, R denoting the starting row, C, denoting the starting column, and G, denoting the number of coins to be collected.\n\nOutput\nFor each test case, output two lines. First line contains K, the number of column visited before completion of game. Second line contains K space separated integers, the number of coins collected from the cells, in the order they were collected.\nIt is guaranteed that a solution exists. And if there are multiple solutions, print any of them.\n\nConstraints\n1 \u2264 T \u2264 100000 \u2264 C \u2264 490 \u2264 R \u2264 991 \u2264 G \u2264 10^12\n\nExample\nInput:\n3\n3 2 5\n3 3 10\n5 4 7\n\nOutput:\n2\n3 2 \n1\n10 \n3\n5 1 1\n\nExplanation\nExample case 1. We first pick 3 coins from [3, 2] then we pick 2 coins from [2, 1]Example case 2. As 3rd column contains 10 coins in cell [5, 3] we pick it.Example case 3. We first pick 5 coins from [5, 4] then we pick 1 coin from [3, 3] and again we pick 1 coin from [2, 2].\n\n### Signature\ndef solve_problem(input_str: str) -> str:",
        "timestamp": "2025-10-16T21:01:13.896941",
        "response_time": "4.62",
        "context": "{\"function_name\": \"solve_problem\", \"difficulty\": 3, \"difficulty_label\": \"HARD\"}"
    },
    {
        "dataset_name": "code_contests_chatgpt4o",
        "dataset_row_id": 19.0,
        "solution": "```python\n===START===\ndef solve_problem(input_str: str) -> str:\n    input_lines = input_str.strip().split(\"\\n\")\n    T = int(input_lines[0])  # Number of test cases\n    result = []\n    idx = 1  # Pointer to the current line in input_lines\n\n    for _ in range(T):\n        # Read N and K\n        N, K = map(int, input_lines[idx].split())\n        idx += 1\n\n        # Read the dictionary of the forgotten language\n        forgotten_words = input_lines[idx].split()\n        idx += 1\n\n        # Collect all words from the modern phrases\n        modern_words = set()\n        for _ in range(K):\n            phrase = input_lines[idx].split()[1:]  # Skip the first number (L)\n            modern_words.update(phrase)\n            idx += 1\n\n        # Determine if each forgotten word is in modern words\n        result.append(\" \".join(\"YES\" if word in modern_words else \"NO\" for word in forgotten_words))\n\n    return \"\\n\".join(result)\n===END===\n```",
        "llm_name": "openai/gpt-4o-2024-11-20",
        "prompt": "### Prompt\nForgotten languages (also known as extinct languages) are languages that are no longer in use. Such languages were, probably, widely used before and no one could have ever imagined that they will become extinct at some point. Unfortunately, that is what happened to them. On the happy side of things, a language may be dead, but some of its words may continue to be used in other languages.\n\n\nUsing something called as the Internet, you have acquired a dictionary of N words of a forgotten language. Meanwhile, you also know K phrases used in modern languages. For each of the words of the forgotten language, your task is to determine whether the word is still in use in any of these K modern phrases or not.\n\n\nInput\n\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\n\n\nThe first line of a test case description contains two space separated positive integers N and K.\n\n\nThe second line of the description contains N strings denoting a dictionary of the forgotten language.\n\n\nEach of the next K lines of the description starts with one positive integer L denoting the number of words in the corresponding phrase in modern languages. The integer is followed by L strings (not necessarily distinct) denoting the phrase.\n\n\nOutput\nFor each test case, output a single line containing N tokens (space-separated): if the i^th word of the dictionary exists in at least one phrase in modern languages, then you should output YES as the i^th token, otherwise NO.\n\nConstraints\n\n1 \u2264 T \u2264 20\n1 \u2264 N \u2264 100\n1 \u2264 K, L \u2264 50\n1 \u2264 length of any string in the input \u2264 5\n\n\nExample\nInput:\n2\n3 2\npiygu ezyfo rzotm\n1 piygu\n6 tefwz tefwz piygu ezyfo tefwz piygu\n4 1\nkssdy tjzhy ljzym kegqz\n4 kegqz kegqz kegqz vxvyj\n\nOutput:\nYES YES NO \nNO NO NO YES\n\n### Signature\ndef solve_problem(input_str: str) -> str:",
        "timestamp": "2025-10-16T21:01:17.839604",
        "response_time": "3.94",
        "context": "{\"function_name\": \"solve_problem\", \"difficulty\": 1, \"difficulty_label\": \"EASY\"}"
    }
]